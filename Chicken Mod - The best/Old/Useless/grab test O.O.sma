/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <xs>
#include <fakemeta>

#define PLUGIN "New Plug-In"
#define VERSION "1.0"
#define AUTHOR "author"


public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_clcmd("+aim", "CmdAimOn")
	register_clcmd("-aim", "CmdAimOff")
}

new g_iInGrab
new g_iGrabEnt
new Float:g_flGrabDistance

public client_PreThink(id)
{
	if(g_iInGrab != id)
	{
		return;
	}
	
	static Float:vOrigin[3], Float:vAngles[3], Float:vViewOfs[3]
	
	entity_get_vector(id, EV_VEC_origin, vOrigin)
	//entity_get_vector(id, EV_VEC_v_angle, vAngles)
	//entity_get_vector(id, EV_VEC_view_ofs, vViewOfs)
	
	xs_vec_add(vOrigin, vViewOfs, vOrigin)
	
	//server_print("vOrigin %0.2f %0.2f %0.2f", vOrigin[0], vOrigin[1], vOrigin[2])
	
	//angle_vector(vAngles, ANGLEVECTOR_FORWARD, vAngles)
	//server_print("vAngles after convert %0.2f %0.2f %0.2f", vAngles[0], vAngles[1], vAngles[2])
	
	//xs_vec_mul_scalar(vAngles, 
	//xs_vec_add(vAngles, Float:{ g_flGrabDistance, g_flGrabDistance, g_flGrabDistance }, vAngles )
	//vAngles[0] += g_flGrabDistance
	//vAngles[1] += g_flGrabDistance
	//vAngles[2] += g_flGrabDistance
	//vAngles[0] *= g_flGrabDistance
	//vAngles[1] *= g_flGrabDistance
	//vAngles[2] *= g_flGrabDistance
	
	//server_print("vAngles after mul %0.2f %0.2f %0.2f", vAngles[0], vAngles[1], vAngles[2])
	
	velocity_by_aim(id, floatround(g_flGrabDistance), vAngles)
	xs_vec_add(vAngles, vOrigin, vAngles)
	//server_print("vAngles after add %0.2f %0.2f %0.2f", vAngles[0], vAngles[1], vAngles[2])
	
	entity_set_origin(g_iGrabEnt, vAngles)
	
}

public CmdAimOn(id)
{
	new iHitEnt
	if(GetHitAimStuff(id, iHitEnt))
	{
		if(is_valid_ent(iHitEnt))
		{
			g_iGrabEnt = iHitEnt
			g_iInGrab = id
			
			g_flGrabDistance = entity_range(id, iHitEnt)
		}
		
		//server_print("iHitEnt = %d", iHitEnt)
	}
}

stock IsEntStuck(iEnt)
{
	if(!is_valid_ent(iEnt))
	{
		return 0;
	}
	
	new Float:vSize[2][3], Float:vOrigin[3];
	pev(iEnt, pev_origin, vOrigin);
	pev(iEnt, pev_mins, vSize[0]);
	pev(iEnt, pev_maxs, vSize[1]);
	
	new Float:flPosition[3];
	new iStuckPoints;
	for(new i, j; i < 2; i++)
	{
		for(j = 0; j < 3; j++)
		{
			flPosition[j] = vOrigin[j] + vSize[i][j];
			
			if(point_contents(flPosition) == CONTENTS_EMPTY)
			{
				return 0;
				//iStuckPoints++;
			}
		}
	}
	
	return 1;
}

public CmdAimOff(id)
{
	if(IsEntStuck(g_iGrabEnt))
	{
		client_print(id, print_chat, "Stuck")
	}
	
	g_iInGrab = 0
	g_iGrabEnt = 0
}

stock GetHitAimStuff(id, &iHitEnt, Float:vEndPoint[3] = { 0.0, 0.0, 0.0 }, iAddPlane = 1)
{
	new iTr = create_tr2();
	
	new Float:vOrigin[3], Float:vAngles[3], Float:vViewOfs[3];
	pev(id, pev_origin, vOrigin);
	pev(id, pev_v_angle, vAngles);
	pev(id, pev_view_ofs, vViewOfs);
	
	xs_vec_add(vOrigin, vViewOfs, vOrigin);
	angle_vector(vAngles, ANGLEVECTOR_FORWARD, vAngles);

	vEndPoint = Float:{ 0.0, 0.0, 0.0 };
	xs_vec_mul_scalar(vAngles, 9999.0, vAngles);
	xs_vec_add(vAngles, vOrigin, vAngles);
	
	//(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	engfunc(EngFunc_TraceLine, vOrigin, vAngles, DONT_IGNORE_MONSTERS, id, iTr);
	
	new flFraction;
	get_tr2(iTr, TR_flFraction, flFraction);
	
	if(flFraction == 1.0)
	{
		console_print(0, "No solid place in sight to place spawn origin. IMPOSSIBLE!!");
		return 0;
	}
	
	get_tr2(iTr, TR_vecEndPos, vEndPoint);
	
	if(iAddPlane)
	{
		new Float:vPlane[3];
		get_tr2(iTr, TR_vecPlaneNormal, vPlane);
		xs_vec_add(vEndPoint, vPlane, vEndPoint);
	}
	
	//Draw(vOrigin, vEndPoint, 50, 0, 255, 0, 255, 2, 0);
	
	iHitEnt = get_tr2(iTr, TR_pHit);
	free_tr2(iTr);
	return 1;
}
