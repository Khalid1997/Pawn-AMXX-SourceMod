/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <multimod>

#define VOTING_TIME 17
#define MAX_VOTE_MAPS 5

//#define ALLOW_VOTE_SAME_MOD

new bool:g_bVotingStarted = false;
new bool:g_bForceChange = false;

new String:g_szNextMap[60];

new Handle:gMapsVoteMenu;
new Handle:gModVoteMenu;

new g_iNextMod = -1

new Handle:gMapsList;

new Handle:gForwardHandle;

public Plugin:myinfo = 
{
	name = "MapChooser Multimod",
	author = "Khalid",
	description = "Voting system for Multimod plugin",
	version = "1.0",
	url = "No"
}

/*
public OnMapTimeLeftChanged()
{
	if (GetArraySize(g_MapList))
	{
		SetupTimeleftTimer();
	}
}*/

public OnPluginStart()
{
	gForwardHandle = CreateGlobalForward("Voting_VoteStarted", ET_Ignore, Param_Cell);
	//gForwardHandle = CreateGlobalForward("Voting_VoteEnded", ET_Ignore, Param_Cell);
	gMapsList = CreateArray(60);
	
	//g_iMaxPlayers = GetMaxClients();
	
	RegAdminCmd("sm_votemod", AdminCmdStartVote, ADMFLAG_ROOT, "Starts mod voting");
}

public OnMapEnd()
{
	// Not needed
	//CloseHandle(gTimer);
}

public OnMapStart()
{
	g_bVotingStarted = false;
	g_bForceChange = false;
	g_iNextMod = -1;
	
	ClearArray(gMapsList);
	ClearArray(gMapsList);
	
	CreateTimer(3.0, Func_Timer,_, TIMER_REPEAT | TIMER_FLAG_NO_MAPCHANGE);
}

public Action:AdminCmdStartVote(client, iArgs)
{
	if(g_bVotingStarted)
	{
		PrintToConsole(client, "** Voting has already started.");
		return Plugin_Handled;
	}
	
	g_bForceChange = true;
	StartVoting();
	PrintToConsole(client, "** Started the vote");
	
	return Plugin_Handled;
}


public Action:Func_Timer(Handle:hTimer)
{
	if(g_bVotingStarted)
	{
		return Plugin_Stop;
	}
	
	static iTime;
	if(GetMapTimeLeft(iTime) && iTime > 0)
	{
		if( iTime <= (3 * 60) )
		{
			StartVoting();
			return Plugin_Stop;
		}
	}
	
	else
	{
		return Plugin_Stop;
	}
	
	return Plugin_Continue;
}

StartVoting()
{
	g_bVotingStarted = true;
	new iNum
	if( ( iNum = MultiMod_GetNextModId() ) != -1)
	{
		PrintToChatAll("[MultiMod] Skipped MOD voting as the next MOD was chosen by an ADMIN");
		
		g_iNextMod = iNum
		Func_StartMapVote(Handle:0);
		return;
	}
	
	new Handle:hModsNames = MultiMod_GetNameArray()
	
	gModVoteMenu = CreateMenu(VotingHandler, MENU_ACTIONS_ALL);
	SetMenuExitButton(gModVoteMenu, false);
	SetMenuTitle(gModVoteMenu, "Choose the next MOD:");
	
	new iSize = GetArraySize(hModsNames);
	
	#if !defined ALLOW_VOTE_SAME_MOD
	new iCurrModId = MultiMod_GetCurrentModId();
	#endif
	
	new i, String:szInfo[5], String:szName[60];
	for(i = 0; i < iSize; i++)
	{
		GetArrayString(hModsNames, i, szName, sizeof(szName));
		IntToString(i, szInfo, sizeof(szInfo));
		
		#if !defined ALLOW_VOTE_SAME_MOD
			if( i == iCurrModId )
			{
				Format(szName, sizeof szName, "%s (Current Mod)", szName);
				AddMenuItem(gModVoteMenu, szInfo, szName, ITEMDRAW_DISABLED);
				continue;
			}
		#endif
		
		AddMenuItem(gModVoteMenu, szInfo, szName, ITEMDRAW_DEFAULT);
	}
		
	/*
	for(i = 1; i <= g_iMaxPlayers; i++)
	{
		if(IsClientInGame(i))
		{
			
		}
	}*/
	
	VoteMenuToAll(gModVoteMenu, VOTING_TIME);
	PrintToChatAll("[MultiMod] Voting for the next MOD has started!");
	LogMessage("[MultiMod] Voting for the next MOD has started!");

	//DisplayMenu(gVotingMenu, 
	
	Call_StartForward(gForwardHandle);
	Call_PushCell(0);
	Call_Finish();
}

public VotingHandler(Handle:menu, MenuAction:iAction, iParam1, iParam2)
{
	switch (iAction)
	{
		case MenuAction_Select:
		{
			new String:szInfo[60], String:szName[60], iDump;
			GetMenuItem(menu, iParam2, szInfo, sizeof szInfo, iDump, szName, sizeof szName);
			
			//new String:szModProps[4][60];
			//MultiMod_GetModProps(StringToInt(szInfo), szModProps[0], sizeof szModProps[]);
			
			new String:szPlayerName[60];
			GetClientName(iParam1, szPlayerName, sizeof szPlayerName);
			
			if(menu == gMapsVoteMenu)
			{
				PrintToChatAll("%s chose %s", szPlayerName, szName);
			}
			
			else
			{
				PrintToChatAll("%s chose the MOD: %s", szPlayerName, szName);
			}
		}
		
		case MenuAction_VoteEnd:
		{
			new String:szInfo[5], String:szName[60], iDump;
			GetMenuItem(menu, iParam1, szInfo, sizeof szInfo, iDump, szName, sizeof szName);
			
			if(menu == gModVoteMenu)
			{
				new iWinner;
				iWinner = StringToInt(szInfo);
				
				MultiMod_SetNextMod(iWinner);
				g_iNextMod = iWinner
			}
				
			else if(gMapsVoteMenu == menu)
			{
				g_szNextMap = szInfo;
			}
			
			new iWinningVotes, iTotal;
			GetMenuVoteInfo(iParam2, iWinningVotes, iTotal);
			PrintToChatAll("[MultiMod] The next %s will be: %s (won by %d votes out of %d)", menu == gMapsVoteMenu ? "map" : "MOD", szName, iWinningVotes, iTotal);
		}
		
		case MenuAction_End:
		{			
			CloseHandle(menu);
			
			if(menu == gMapsVoteMenu)
			{
				DecideNextMap(g_szNextMap);
			}
			
			else 
			{
				CreateTimer(5.0, Func_StartMapVote);
			}
		}
	}
}

public Action:Func_StartMapVote(Handle:hTimer)
{
	gMapsVoteMenu = CreateMenu(VotingHandler, MENU_ACTIONS_ALL)
	new iMapsCount = ReadMapsFile()
	if(!iMapsCount)
	{
		PrintToChatAll("[MultiMod] Map voting was cancelled as there are no available maps to vote on.");
		DecideNextMap("")
		return;
	}
	
	new iVoteMapsCount = iMapsCount > MAX_VOTE_MAPS ? MAX_VOTE_MAPS : iMapsCount;
	
	new Array[GetArraySize(gMapsList)];
	new String:szMapName[60];
	for(new i, iMapIndex; i < iVoteMapsCount; i++)
	{
		iMapIndex = GetRandomInt(0, iMapsCount - 1);
		if(Array[iMapIndex])
		{
			continue;
		}
		
		GetArrayString(gMapsList, iMapIndex, szMapName, sizeof szMapName);
		AddMenuItem(gMapsVoteMenu, szMapName, szMapName);
	}
	
	PrintToChatAll("[MultiMod] Voting for the next map has started!");
	LogMessage("[MultiMod] Voting for the next map has started!");
	
	VoteMenuToAll(gMapsVoteMenu, VOTING_TIME);
}

DecideNextMap(String:szInfo[])
{
	if(!szInfo[0])
	{
		GetCurrentMap(g_szNextMap, sizeof g_szNextMap);
	}
	
	SetNextMap(g_szNextMap);
	
	if(g_bForceChange)
	{
		CreateTimer(4.0, Func_ChangeMap);
	}
}

public Action:Func_ChangeMap(Handle:hTimer)
{
	ServerCommand("changelevel %s", g_szNextMap);
}

ReadMapsFile()
{
	new String:szMapsFile[60];
	MultiMod_GetModProps(g_iNextMod, MP_MAP, szMapsFile, sizeof szMapsFile);
	
	new String:szFile[120];
	FormatEx(szFile, sizeof szFile, "cfg/multimod/%s-maps.ini", szMapsFile);
	
	new Handle:f = OpenFile(szFile, "r");
	if(f == INVALID_HANDLE)
	{
		PrintToServer("****** File not found %s", szFile);
		if(!szMapsFile[0])
		{
			
			return 0;
		}
		
		f = OpenFile(szFile, "w");
		
		WriteFileLine(f,
		 "; --------------------------------------------------------------------------------------------------\
		\n;|                                    MultiMod Maps File                                          |\
		\n; --------------------------------------------------------------------------------------------------\
		\n; Any line beginning with a ';', '#' or '//' is a comment.\
		\n; Write each map in one line without the .bsp extension.");
		
		CloseHandle(f);
		
		return 0;
	}
	
	PrintToServer("** File Read");
	
	new String:szLine[200], iMaps;
	while(!IsEndOfFile(f) && ReadFileLine(f, szLine, sizeof szLine))
	{
		TrimString(szLine);
		
		if(!szLine[0] || szLine[0] == ';' || szLine[0] == '#' || ( szLine[0] == '/' && szLine[1] == '/' ) )
		{
			continue;
		}
		
		if(StrContains(szLine, ".bsp", false) != -1)
		{
			ReplaceString(szLine, sizeof szLine, ".bsp", "");
		}
		
		PrintToServer(szLine);
		
		if(IsMapValid(szLine))
		{
			PushArrayString(gMapsList, szLine);
			++iMaps;
		}
	}
	
	CloseHandle(f);
	
	return iMaps;
}