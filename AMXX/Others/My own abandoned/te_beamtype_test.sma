/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>

#define PLUGIN "New Plug-In"
#define VERSION "1.0"
#define AUTHOR "author"

#define TASKID_MAKE 15115

static const szINFO[][] = {
	"Scroll",
	"Brightness",
	"Amplitude",
	"Width"
}
	
new DEFAULT[] = {
	15 / 20,
	255,
	10,
	70
}

new INFO[] = {
	15 / 20,
	16,
	10,
	70
}

new g_iOn[33]

new hnr_winbeam
new Float:g_flDuration

new g_iMenu[33]

enum _:TYPES
{
	iTYPE,
	szTYPE[50]
}

new gTYPES[][TYPES] = {
	{ TE_BEAMCYLINDER, "TE_BEAMCYLINDER" },
	{ TE_BEAMDISK, "TE_BEAMDISK" },
	{ TE_BEAMTORUS, "TE_BEAMTORUS" }
}

new g_iType

public plugin_precache()
{
	hnr_winbeam = precache_model("sprites/laserbeam.spr")
}

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_concmd("say /type", "CmdType")
	register_clcmd("say /players", "CmdTest")
	register_clcmd("say /duration", "CmdDuration")
	
	register_concmd("amx_make", "CmdMake", -1, "<Scroll> <Brightness> <Amplitude> <Width>")
	
	register_clcmd("say /reset", "CmdReset")
	register_concmd("amx_reset", "CmdReset")
	register_clcmd("say", "CmdDuration")
	
	register_concmd("amx_print", "CmdPrint")
}

public DestroyMenu(id)
{
	menu_destroy(g_iMenu[id])
	g_iMenu[id] = 0
}

public CmdType(id)
{
	new iMenu = CreateMenu(id, "Choose a type", "type_handler")

	for(new i; i < sizeof(gTYPES); i++)
	{
		menu_additem(iMenu, gTYPES[i][szTYPE], .paccess =  ( i == g_iType ? 1<<27 : 0 ) )
	}
	
	menu_display(id, iMenu)
}

public type_handler(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		DestroyMenu(id)
		return;
	}
	
	g_iType = item	
	client_print(id, print_chat, "New type is %s", gTYPES[item][szTYPE])
	
	DestroyMenu(id)
}

stock CreateMenu(id, szTitle[], szHandler[])
{
	if(g_iMenu[id])
	{
		DestroyMenu(id)
	}
	
	g_iMenu[id] = menu_create(szTitle, szHandler)
	return g_iMenu[id]
}
	
public CmdPrint(id)
{
	for(new i; i < 4; i++)
	{
		console_print(id, "%s is %d", szINFO[i], INFO[i])
	}
	
	console_print(id, "Duration is %0.2f", g_flDuration)
	
	return PLUGIN_HANDLED
}

public CmdDuration(id)
{
	static szSaid[60], szDuration[10]
	read_argv(1, szSaid, 59)
	parse(szSaid, szSaid, 59, szDuration, 9)
	
	if(!equali(szSaid, "/duration"))
	{
		return;
	}
	
	g_flDuration = str_to_float(szDuration)
	
	client_print(id, print_chat, "Duration %f", g_flDuration)
}

public CmdReset(id)
{
	for(new i; i < 3; i++)
	{
		INFO[i] = DEFAULT[i]
	}
	
	client_print(id, print_chat, "RESET")
	console_print(id, "RESET")
}

public CmdMake(id, level, cid)
{
	if(!cmd_access(id, level, cid, 2))
	{
		return PLUGIN_HANDLED
	}
	
	new szArgs[4][7]
	
	new szConsole[300], iLen
	iLen = formatex(szConsole, charsmax(szConsole), "Got value of:^n")
	for(new i, b = 1; b <= 4; i++, b++)
	{
		read_argv(b, szArgs[i], 6)
		
		if(szArgs[i][0])
		{
			INFO[i] = str_to_num(szArgs[i])
			
			iLen += formatex(szConsole[iLen], charsmax(szConsole) - iLen, "%s %s^n", szINFO[i], szArgs[i])
		}
	}
	
	console_print(id, szConsole)
	
	return PLUGIN_HANDLED
}

public client_connect(id)
{
	g_iOn[id] = 0
	if(task_exists(id + TASKID_MAKE))
	{
		remove_task(id + TASKID_MAKE)
	}
}

public CmdTest(id)
{
	new iMenu = CreateMenu(id, "Choose A Player", "player_handler")
	
	new iPlayers[32], iNum, iPlayer, szInfo[5]
	get_players(iPlayers, iNum, "ah")
	
	new szName[32], newname[50]
	
	for(new i; i < iNum; i++)
	{
		get_user_name( ( iPlayer = iPlayers[i] ), szName, 31)
		num_to_str(iPlayer, szInfo, 4)
		
		formatex(newname, 49, "%s \w[\r%s\w]", szName, g_iOn[iPlayer] ? "On" : "Off")
		
		menu_additem(iMenu, newname, szInfo)
	}
	
	menu_display(id, iMenu)
}

public player_handler(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		DestroyMenu(id)
		return;
	}
	
	new szInfo[5], iDump, iPlayer, szName[32]
	
	menu_item_getinfo(menu ,item, iDump, szInfo, 4, .callback = iDump)
	
	new newname[50]
	
	iPlayer = str_to_num(szInfo)
	get_user_name(iPlayer, szName, charsmax(szName))
	
	g_iOn[iPlayer] = !g_iOn[iPlayer]
	
	if(g_iOn[iPlayer])
	{
		formatex(newname, 49, "%s \w[\rOn\w]", szName)
		set_task(g_flDuration, "Make", iPlayer + TASKID_MAKE, .flags = "b")
	}
	
	else
	{
		formatex(newname, 49, "%s \w[\rOff\w]", szName)
		remove_task(iPlayer + TASKID_MAKE)
	}
	
	menu_item_setname(menu, item, newname)
	
	menu_display(id, menu)
}

public Make(taskid)
{
	new id = taskid - TASKID_MAKE
	
	static iOrigin[3]; get_user_origin(id, iOrigin, 0)
	
	Effect(iOrigin, random(256), random(256), random(256))
}

stock Effect( Origin[ 3 ], r, g, b )
{
	message_begin( MSG_BROADCAST, SVC_TEMPENTITY );
	write_byte( gTYPES[g_iType][iTYPE] );
	write_coord( Origin[ 0 ] );		// position.x
	write_coord( Origin[ 1 ] );		// position.y
	write_coord( Origin[ 2 ] - 20 );		// position.z
	write_coord( Origin[ 0 ] );    		// axis.x
	write_coord( Origin[ 1 ] );   		// axis.y
	write_coord( Origin[ 2 ] + 350 );	// axis.z
	write_short( hnr_winbeam );		// sprite index
	write_byte( 0 );       			// starting frame
	write_byte( 0 );       			// frame rate in 0.1's
	write_byte( 10 );        		// life in 0.1's
	write_byte( INFO[3] );        		// line width in 0.1's
	write_byte( INFO[2] );        		// noise amplitude in 0.01's
	write_byte( r );			// r
	write_byte( g );			// g
	write_byte( b );			// b
	write_byte( INFO[1]);			// brightness
	write_byte( INFO[0] );			// scroll speed in 0.1's
	message_end( );
}
