/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta>
#include <engine>
#include <hamsandwich>
#include <xs>

#define PLUGIN "New Plug-In"
#define VERSION "1.0"
#define AUTHOR "author"

new bool:g_bModel = false

new beampoint
new g_ent_playermodel[33]

public plugin_precache()
{
	beampoint = precache_model("sprites/laserbeam.spr")
	precache_model("models/rpgrocket.mdl");
}

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)
	register_impulse(100, "fw_Check");
	register_impulse(201, "fw_Reset");
}

public fw_Reset(id)
{
	g_bModel = false;
}

public fw_Check(id)
{
	if(g_bModel)
	{
		return PLUGIN_HANDLED;
	}
	
	static iEnt;
	GetHitEnt(id, iEnt);
	
	new szClassName[32]
	
	server_print("iEnt = %d", iEnt);
	
	if(iEnt > 0)
	{
		pev(iEnt, pev_classname, szClassName, 31);
		static szModel[100]
		pev(iEnt, pev_model, szModel, charsmax(szModel));
		//set_pev(id, pev_model, szModel);
		
		server_print("Model %s", szModel);
		///entity_set_model(id, szModel);
		//fm_set_playermodel_ent(id, szMod
		
		g_bModel = true;
	}
	
	server_print("iEnt = %d - %s", iEnt, szClassName)

	return PLUGIN_HANDLED;
}

stock GetHitEnt(id, &iEnt, Float:vOrigin[3] = { 0.0, 0.0, 0.0 })
{
	if(!is_user_connected(id))
	{
		return 0
	}
	
	new iTr = create_tr2()
				
	new Float:vTraceEnd[3], Float:vViewOfs[3]
	
	entity_get_vector(id, EV_VEC_origin, vOrigin)
	entity_get_vector(id, EV_VEC_view_ofs, vViewOfs)
	entity_get_vector(id, EV_VEC_v_angle, vTraceEnd)
	
	// Get player camera Z vector
	xs_vec_add(vOrigin, vViewOfs, vOrigin)
	
	angle_vector(vTraceEnd, ANGLEVECTOR_FORWARD, vTraceEnd)
	
	velocity_by_aim(id, 9999, vTraceEnd)
	
	xs_vec_add(vOrigin, vTraceEnd, vTraceEnd)
			
	engfunc(EngFunc_TraceLine, vOrigin, vTraceEnd, DONT_IGNORE_MONSTERS, id, iTr);
				
	new Float:flFraction
	get_tr2(iTr, TR_flFraction, flFraction)
				
	if(flFraction == -1)
	{
		free_tr2(iTr)
		return 0
	}
	
	iEnt = get_tr2(iTr, TR_pHit);
	get_tr2(iTr, TR_vecEndPos, vTraceEnd)
	draw_laser(vOrigin, vTraceEnd)
	xs_vec_copy(vTraceEnd, vOrigin)
	
	iEnt = get_tr2(iTr, TR_pHit);
	free_tr2(iTr)
	
	return iEnt
}

stock draw_laser(Float:origin[3], Float:endpoint[3])
{                    
	message_begin(MSG_ALL, SVC_TEMPENTITY)
	write_byte(TE_BEAMPOINTS)
	engfunc(EngFunc_WriteCoord, origin[0])
	engfunc(EngFunc_WriteCoord, origin[1])
	engfunc(EngFunc_WriteCoord, origin[2])
	engfunc(EngFunc_WriteCoord, endpoint[0])
	engfunc(EngFunc_WriteCoord, endpoint[1])
	engfunc(EngFunc_WriteCoord, endpoint[2])
	write_short(beampoint)
	write_byte(0)
	write_byte(0)
	write_byte(100) // In tenths of a second.
	write_byte(10)
	write_byte(1)
	write_byte(255) // Red
	write_byte(0) // Green
	write_byte(0) // Blue
	write_byte(127)
	write_byte(1)
	message_end()
}  

stock fm_set_playermodel_ent( id, const modelname[] )
{
    // Make original player entity invisible
    set_pev( id, pev_rendermode, kRenderTransTexture )
    // This is not 0 because it would hide the shadow and some effects when firing weapons
    set_pev( id, pev_renderamt, 1.0 )
    
    // Since we're passing the short model name to the function
    // we need to make the full path out of it
    static modelpath[100]
    formatex( modelpath, charsmax( modelpath ), "models/player/%s/%s.mdl", modelname, modelname )
    
    // Check if the entity assigned to this player exists
    if ( !pev_valid( g_ent_playermodel[id] ) )
    {
        // If it doesn't, proceed to create a new one
        g_ent_playermodel[id] = engfunc( EngFunc_CreateNamedEntity, engfunc( EngFunc_AllocString, "info_target" ) )
        
        // If it failed to create for some reason, at least this will prevent further "Invalid entity" errors...
        if ( !pev_valid( g_ent_playermodel[id] ) ) return;
        
        // Set its classname
        set_pev( g_ent_playermodel[id], pev_classname, "model_fake" )
        
        // Make it follow the player
        set_pev( g_ent_playermodel[id], pev_movetype, MOVETYPE_FOLLOW )
        set_pev( g_ent_playermodel[id], pev_aiment, id )
        set_pev( g_ent_playermodel[id], pev_owner, id )
    }
    
    // Entity exists now, set its model
    engfunc( EngFunc_SetModel, g_ent_playermodel[id], modelpath )
}